/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function POST(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get employee_id for the authenticated user
    const employeeResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (employeeResult.length === 0) {
      return NextResponse.json({ error: 'User profile not found' }, { status: 404 });
    }
    const employee_id = employeeResult[0].id;
    
    const body = await request.json();
    const { description, project_id, task_id, start_time, end_time, duration_minutes, is_billable, is_running, hourly_rate, tags } = body;
    
    if (!start_time) {
      return NextResponse.json({ error: 'Start time is required' }, { status: 400 });
    }
    
    // If starting a running timer, stop any existing running timers for this user
    if (is_running) {
      const stopQuery = `
        UPDATE time_entries 
        SET is_running = false, 
            end_time = CURRENT_TIMESTAMP,
            duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - start_time)) / 60,
            updated_at = CURRENT_TIMESTAMP
        WHERE employeeid = ? AND is_running = true
      `;
      await db_query(db, stopQuery, [employee_id]);
    }
    
    // Calculate duration if end_time provided but duration not
    let calculatedDuration = duration_minutes;
    if (end_time && !duration_minutes) {
      const startDate = new Date(start_time);
      const endDate = new Date(end_time);
      calculatedDuration = Math.round((endDate - startDate) / 60000);
    }
    
    const entryId = crypto.randomUUID();
    
    const insertQuery = `
      INSERT INTO time_entries (
        id, employeeid, project_id, task_id, description, start_time, end_time,
        duration_minutes, is_running, is_billable, hourly_rate, tags
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      RETURNING *
    `;
    
    const params = [
      entryId,
      employee_id,
      project_id || null,
      task_id || null,
      description || null,
      start_time,
      end_time || null,
      calculatedDuration || null,
      is_running || false,
      is_billable !== false,
      hourly_rate || null,
      JSON.stringify(tags || [])
    ];
    
    const result = await db_query(db, insertQuery, params);
    const entry = result[0];
    
    return NextResponse.json({
      id: entry.id,
      employeeid: entry.employeeid,
      project_id: entry.project_id,
      task_id: entry.task_id,
      description: entry.description,
      start_time: entry.start_time,
      end_time: entry.end_time,
      duration_minutes: parseInt(entry.duration_minutes) || 0,
      is_running: entry.is_running,
      is_billable: entry.is_billable,
      created_at: entry.created_at
    }, { status: 201 });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create time entry', message: error.message },
      { status: 500 }
    );
  }
}


