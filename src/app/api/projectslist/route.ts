/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function GET(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status') || '';
    const priority = searchParams.get('priority') || '';
    const owner_id = searchParams.get('owner_id') || '';
    const sort_by = searchParams.get('sort_by') || 'updated_at';
    const sort_order = (searchParams.get('sort_order') || 'DESC').toUpperCase();
    
    if (sort_order !== 'ASC' && sort_order !== 'DESC') {
      return NextResponse.json({ error: 'Invalid sort order' }, { status: 400 });
    }
    
    // Get employee ID for current user
    const empQuery = `SELECT id FROM employees WHERE userid = ?`;
    const empResult = await db_query(db, empQuery, [user_id]);
    const employeeId = empResult.length > 0 ? empResult[0].id : null;
    
    const conditions = [];
    const values = [];
    
    // Access control - user must be owner or member (unless admin)
    if (!is_admin && employeeId) {
      conditions.push(`(p.owner_id = ? OR pm.employee_id = ?)`);
      values.push(employeeId, employeeId);
    }
    
    if (search) {
      conditions.push(`(LOWER(p.name) LIKE LOWER(?) OR LOWER(p.description) LIKE LOWER(?))`);
      values.push(`%${search}%`, `%${search}%`);
    }
    
    if (status) {
      conditions.push('p.status = ?');
      values.push(status);
    }
    
    if (priority) {
      conditions.push('p.priority = ?');
      values.push(priority);
    }
    
    if (owner_id) {
      conditions.push('p.owner_id = ?');
      values.push(owner_id);
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    // Count query
    const countQuery = `
      SELECT COUNT(DISTINCT p.id) as count 
      FROM projects p
      LEFT JOIN project_members pm ON p.id = pm.project_id
      ${whereClause}
    `;
    const countResult = await db_query(db, countQuery, values);
    const total = parseInt(countResult[0].count);
    
    const offset = (page - 1) * limit;
    const pages = Math.ceil(total / limit);
    
    const allowedSortFields = ['name', 'status', 'priority', 'created_at', 'updated_at', 'due_date', 'progress'];
    const finalSortBy = allowedSortFields.includes(sort_by) ? sort_by : 'updated_at';
    
    const dataQuery = `
      SELECT DISTINCT
        p.id, p.name, p.slug, p.description, p.owner_id, p.status, p.priority,
        p.visibility, p.color, p.icon, p.start_date, p.due_date, p.completed_at,
        p.budget, p.budget_spent, p.progress, p.task_count, p.completed_task_count,
        p.settings, p.metadata, p.created_at, p.updated_at
      FROM projects p
      LEFT JOIN project_members pm ON p.id = pm.project_id
      ${whereClause}
      ORDER BY p.${finalSortBy} ${sort_order}
      LIMIT ? OFFSET ?
    `;
    
    const result = await db_query(db, dataQuery, [...values, limit, offset]);
    
    const projects = result.map(p => ({
      id: p.id,
      name: p.name,
      slug: p.slug,
      description: p.description,
      owner_id: p.owner_id,
      status: p.status,
      priority: p.priority,
      visibility: p.visibility,
      color: p.color,
      icon: p.icon,
      start_date: p.start_date,
      due_date: p.due_date,
      completed_at: p.completed_at,
      budget: p.budget ? parseFloat(p.budget) : null,
      budget_spent: parseFloat(p.budget_spent) || 0,
      progress: parseInt(p.progress) || 0,
      task_count: parseInt(p.task_count) || 0,
      completed_task_count: parseInt(p.completed_task_count) || 0,
      settings: p.settings,
      metadata: p.metadata,
      created_at: p.created_at,
      updated_at: p.updated_at
    }));
    
    return NextResponse.json({
      data: projects,
      pagination: { total, pages, current: page, limit }
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to list projects', message: error.message },
      { status: 500 }
    );
  }
}


