/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function POST(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const body = await request.json();
    const {
      client_name,
      client_email,
      client_address,
      issue_date,
      due_date,
      line_items: provided_line_items,
      tax_rate = 0,
      discount_amount = 0,
      currency = 'USD',
      notes,
      payment_terms,
      project_id,
      time_entry_ids = [],
      include_time_entries = false
    } = body;
    
    // Initialize line_items - may be augmented with time entries
    let line_items = provided_line_items || [];
    let validated_time_entry_ids = [];
    
    // Fetch and validate time entries if provided
    if (time_entry_ids && time_entry_ids.length > 0) {
      const placeholders = time_entry_ids.map(() => '?').join(',');
      const timeEntriesQuery = `
        SELECT te.id, te.description, te.duration_minutes, te.hourly_rate, te.is_billable,
               te.project_id, te.task_id, p.name as project_name, t.title as task_title
        FROM time_entries te
        LEFT JOIN projects p ON te.project_id = p.id
        LEFT JOIN tasks t ON te.task_id = t.id
        WHERE te.id IN (${placeholders}) AND te.is_running = false
      `;
      const timeEntries = await db_query(db, timeEntriesQuery, time_entry_ids);
      
      if (timeEntries.length === 0 && time_entry_ids.length > 0) {
        return NextResponse.json(
          { error: 'No valid time entries found for the provided IDs' },
          { status: 400 }
        );
      }
      
      validated_time_entry_ids = timeEntries.map(te => te.id);
      
      // Generate line items from billable time entries if requested
      if (include_time_entries) {
        const timeEntryLineItems = timeEntries
          .filter(te => te.is_billable)
          .map(te => {
            const hours = (te.duration_minutes || 0) / 60;
            const rate = parseFloat(te.hourly_rate) || 0;
            const description = te.description || 
              (te.task_title ? `${te.project_name || 'Project'} - ${te.task_title}` : 
               te.project_name || 'Time Entry');
            return {
              description: description,
              quantity: parseFloat(hours.toFixed(2)),
              rate: rate,
              amount: parseFloat((hours * rate).toFixed(2)),
              time_entry_id: te.id
            };
          });
        
        line_items = [...line_items, ...timeEntryLineItems];
      }
    }
    
    if (!client_name || !issue_date || !due_date || (line_items.length === 0)) {
      return NextResponse.json(
        { error: 'Client name, issue date, due date, and line items are required' },
        { status: 400 }
      );
    }
    
    // Generate invoice number
    const year = new Date().getFullYear();
    const countQuery = `SELECT COUNT(*) as count FROM invoices WHERE customer_id = ? AND invoice_number LIKE ?`;
    const countResult = await db_query(db, countQuery, [customer_id, `INV-${year}-%`]);
    const count = parseInt(countResult[0].count) || 0;
    const invoice_number = `INV-${year}-${String(count + 1).padStart(4, '0')}`;
    
    // Calculate totals
    const subtotal = line_items.reduce((sum, item) => sum + (parseFloat(item.quantity || 1) * parseFloat(item.rate || 0)), 0);
    const tax_amount = subtotal * (parseFloat(tax_rate) / 100);
    const total = subtotal + tax_amount - parseFloat(discount_amount || 0);
    
    const id = crypto.randomUUID();
    
    const query = `
      INSERT INTO invoices (
        id, customer_id, invoice_number, status, issue_date, due_date,
        client_name, client_email, client_address, line_items, subtotal,
        tax_rate, tax_amount, discount_amount, total, currency, notes,
        payment_terms, project_id, time_entry_ids, created_at, updated_at
      ) VALUES (?, ?, ?, 'draft', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `;
    
    await db_query(db, query, [
      id, customer_id, invoice_number, issue_date, due_date,
      client_name, client_email || null, client_address || null,
      JSON.stringify(line_items), subtotal, tax_rate, tax_amount, discount_amount,
      total, currency, notes || null, payment_terms || null, project_id || null,
      JSON.stringify(validated_time_entry_ids.length > 0 ? validated_time_entry_ids : time_entry_ids)
    ]);
    
    return NextResponse.json({
      id,
      invoice_number,
      message: 'Invoice created successfully'
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create invoice', message: error.message },
      { status: 500 }
    );
  }
}


