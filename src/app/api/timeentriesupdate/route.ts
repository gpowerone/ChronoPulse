/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function PUT(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const body = await request.json();
    const { id, description, project_id, task_id, start_time, end_time, duration_minutes, is_billable, is_running, hourly_rate, tags } = body;
    
    if (!id) {
      return NextResponse.json({ error: 'Time entry ID is required' }, { status: 400 });
    }
    
    // Check if entry exists and belongs to customer
    const checkQuery = `SELECT * FROM time_entries WHERE id = ?`;
    const checkResult = await db_query(db, checkQuery, [id]);
    
    if (checkResult.length === 0) {
      return NextResponse.json({ error: 'Time entry not found' }, { status: 404 });
    }
    
    const existingEntry = checkResult[0];
    
    if (existingEntry.customer_id !== customer_id && !is_admin) {
      return NextResponse.json({ error: 'Not authorized to update this entry' }, { status: 403 });
    }
    
    // If starting a running timer, stop any existing running timers for this customer
    if (is_running === true && !existingEntry.is_running) {
      const stopQuery = `
        UPDATE time_entries 
        SET is_running = false, 
            end_time = CURRENT_TIMESTAMP,
            duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - start_time)) / 60,
            updated_at = CURRENT_TIMESTAMP
        WHERE customer_id = ? AND is_running = true AND id != ?
      `;
      await db_query(db, stopQuery, [customer_id, id]);
    }
    
    // Build update query dynamically
    const updates = [];
    const params = [];
    
    if (description !== undefined) {
      updates.push('description = ?');
      params.push(description);
    }
    if (project_id !== undefined) {
      updates.push('project_id = ?');
      params.push(project_id || null);
    }
    if (task_id !== undefined) {
      updates.push('task_id = ?');
      params.push(task_id || null);
    }
    if (start_time !== undefined) {
      updates.push('start_time = ?');
      params.push(start_time);
    }
    if (end_time !== undefined) {
      updates.push('end_time = ?');
      params.push(end_time || null);
    }
    if (duration_minutes !== undefined) {
      updates.push('duration_minutes = ?');
      params.push(duration_minutes);
    } else if (start_time !== undefined || end_time !== undefined) {
      // Recalculate duration if times changed
      const newStart = start_time || existingEntry.start_time;
      const newEnd = end_time || existingEntry.end_time;
      if (newEnd) {
        const startDate = new Date(newStart);
        const endDate = new Date(newEnd);
        const calcDuration = Math.round((endDate - startDate) / 60000);
        updates.push('duration_minutes = ?');
        params.push(calcDuration);
      }
    }
    if (is_billable !== undefined) {
      updates.push('is_billable = ?');
      params.push(is_billable);
    }
    if (is_running !== undefined) {
      updates.push('is_running = ?');
      params.push(is_running);
      // If stopping timer, set end_time and calculate duration
      if (is_running === false && existingEntry.is_running) {
        updates.push('end_time = CURRENT_TIMESTAMP');
        updates.push('duration_minutes = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - start_time)) / 60');
      }
    }
    if (hourly_rate !== undefined) {
      updates.push('hourly_rate = ?');
      params.push(hourly_rate);
    }
    if (tags !== undefined) {
      updates.push('tags = ?');
      params.push(JSON.stringify(tags));
    }
    
    if (updates.length === 0) {
      return NextResponse.json({ error: 'No fields to update' }, { status: 400 });
    }
    
    updates.push('updated_at = CURRENT_TIMESTAMP');
    params.push(id);
    
    const updateQuery = `UPDATE time_entries SET ${updates.join(', ')} WHERE id = ? RETURNING *`;
    const result = await db_query(db, updateQuery, params);
    const entry = result[0];
    
    return NextResponse.json({
      id: entry.id,
      description: entry.description,
      start_time: entry.start_time,
      end_time: entry.end_time,
      duration_minutes: parseInt(entry.duration_minutes) || 0,
      is_running: entry.is_running,
      updated_at: entry.updated_at
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update time entry', message: error.message },
      { status: 500 }
    );
  }
}


