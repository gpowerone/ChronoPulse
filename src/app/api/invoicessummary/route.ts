/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function GET(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const { searchParams } = new URL(request.url);
    const start_date = searchParams.get('start_date');
    const end_date = searchParams.get('end_date');
    
    let conditions = ['customer_id = ?'];
    let params = [customer_id];
    
    if (start_date) {
      conditions.push('issue_date >= ?');
      params.push(start_date);
    }
    
    if (end_date) {
      conditions.push('issue_date <= ?');
      params.push(end_date);
    }
    
    const whereClause = `WHERE ${conditions.join(' AND ')}`;
    
    // Get summary statistics
    const summaryQuery = `
      SELECT 
        COALESCE(SUM(total), 0) as total_invoiced,
        COALESCE(SUM(amount_paid), 0) as total_paid,
        COALESCE(SUM(CASE WHEN status != 'paid' AND status != 'cancelled' THEN total - amount_paid ELSE 0 END), 0) as total_outstanding,
        COUNT(CASE WHEN status = 'sent' AND due_date < CURRENT_DATE THEN 1 END) as overdue_count,
        COUNT(*) as total_count
      FROM invoices
      ${whereClause}
    `;
    
    // Get time tracking statistics for invoices
    const timeTrackingQuery = `
      SELECT 
        COALESCE(SUM(te.duration_minutes), 0) as total_tracked_minutes,
        COALESCE(SUM(CASE WHEN te.is_billable = true THEN te.duration_minutes ELSE 0 END), 0) as billable_minutes,
        COALESCE(SUM(CASE WHEN te.is_billable = true THEN (te.duration_minutes / 60.0) * te.hourly_rate ELSE 0 END), 0) as billable_amount
      FROM time_entries te
      INNER JOIN invoices i ON te.id::text = ANY(SELECT jsonb_array_elements_text(i.time_entry_ids))
      ${whereClause}
    `;
    
    const summaryResult = await db_query(db, summaryQuery, params);
    const summary = summaryResult[0];
    
    // Get time tracking stats
    let timeTrackingStats = { total_tracked_minutes: 0, billable_minutes: 0, billable_amount: 0 };
    try {
      const timeTrackingResult = await db_query(db, timeTrackingQuery, params);
      if (timeTrackingResult.length > 0) {
        timeTrackingStats = timeTrackingResult[0];
      }
    } catch (timeErr) {
      // Time tracking query may fail if no time entries exist, continue with defaults
    }
    
    // Get unbilled time entries for this customer's projects
    const unbilledTimeQuery = `
      SELECT 
        COALESCE(SUM(te.duration_minutes), 0) as unbilled_minutes,
        COALESCE(SUM(CASE WHEN te.is_billable = true THEN (te.duration_minutes / 60.0) * te.hourly_rate ELSE 0 END), 0) as unbilled_amount
      FROM time_entries te
      INNER JOIN projects p ON te.project_id = p.id
      WHERE p.owner_id IN (SELECT id FROM employees WHERE userid = ?)
      AND te.is_billable = true
      AND NOT EXISTS (
        SELECT 1 FROM invoices inv 
        WHERE inv.customer_id = ? 
        AND te.id::text = ANY(SELECT jsonb_array_elements_text(inv.time_entry_ids))
      )
    `;
    
    let unbilledStats = { unbilled_minutes: 0, unbilled_amount: 0 };
    try {
      const unbilledResult = await db_query(db, unbilledTimeQuery, [user_id, customer_id]);
      if (unbilledResult.length > 0) {
        unbilledStats = unbilledResult[0];
      }
    } catch (unbilledErr) {
      // Unbilled query may fail, continue with defaults
    }
    
    // Get breakdown by status
    const breakdownQuery = `
      SELECT 
        status,
        COUNT(*) as count,
        COALESCE(SUM(total), 0) as total_amount
      FROM invoices
      ${whereClause}
      GROUP BY status
      ORDER BY status
    `;
    
    const breakdownResult = await db_query(db, breakdownQuery, params);
    
    return NextResponse.json({
      total_invoiced: parseFloat(summary.total_invoiced) || 0,
      total_paid: parseFloat(summary.total_paid) || 0,
      total_outstanding: parseFloat(summary.total_outstanding) || 0,
      overdue_count: parseInt(summary.overdue_count) || 0,
      total_count: parseInt(summary.total_count) || 0,
      breakdown: breakdownResult.map(row => ({
        status: row.status,
        count: parseInt(row.count) || 0,
        total_amount: parseFloat(row.total_amount) || 0
      })),
      time_tracking: {
        total_tracked_hours: parseFloat(timeTrackingStats.total_tracked_minutes || 0) / 60,
        billable_hours: parseFloat(timeTrackingStats.billable_minutes || 0) / 60,
        billable_amount: parseFloat(timeTrackingStats.billable_amount) || 0,
        unbilled_hours: parseFloat(unbilledStats.unbilled_minutes || 0) / 60,
        unbilled_amount: parseFloat(unbilledStats.unbilled_amount) || 0
      }
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch invoice summary', message: error.message },
      { status: 500 }
    );
  }
}


