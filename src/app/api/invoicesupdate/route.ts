/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function PUT(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const body = await request.json();
    const { id, ...updates } = body;
    
    if (!id) {
      return NextResponse.json(
        { error: 'Invoice ID is required' },
        { status: 400 }
      );
    }
    
    // Check ownership
    const checkQuery = `SELECT * FROM invoices WHERE id = ? AND customer_id = ?`;
    const existing = await db_query(db, checkQuery, [id, customer_id]);
    
    if (existing.length === 0) {
      return NextResponse.json(
        { error: 'Invoice not found' },
        { status: 404 }
      );
    }
    
    const currentInvoice = existing[0];
    let setClause = [];
    let params = [];
    
    // Handle time_entry_ids - integrate with timetracking
    if (updates.time_entry_ids !== undefined && Array.isArray(updates.time_entry_ids) && updates.time_entry_ids.length > 0) {
      // Fetch time entries to generate line items from billable hours
      const placeholders = updates.time_entry_ids.map(() => '?').join(',');
      const timeEntries = await db_query(db, `SELECT id, description, duration_minutes, hourly_rate, is_billable, project_id, task_id FROM time_entries WHERE id IN (${placeholders}) AND userid = ?`, [...updates.time_entry_ids, user_id]);
      
      if (timeEntries.length > 0) {
        // Generate line items from billable time entries
        const timeLineItems = timeEntries
          .filter(entry => entry.is_billable)
          .map(entry => ({
            description: entry.description || 'Time entry',
            quantity: parseFloat((entry.duration_minutes / 60).toFixed(2)),
            rate: parseFloat(entry.hourly_rate || 0),
            amount: parseFloat(((entry.duration_minutes / 60) * (entry.hourly_rate || 0)).toFixed(2))
          }));
        
        // Merge with existing line_items if provided, otherwise use time-based items
        const existingLineItems = updates.line_items !== undefined ? updates.line_items : (currentInvoice.line_items ? JSON.parse(currentInvoice.line_items) : []);
        const mergedLineItems = [...existingLineItems, ...timeLineItems];
        
        updates.line_items = mergedLineItems;
      }
      
      setClause.push('time_entry_ids = ?');
      params.push(JSON.stringify(updates.time_entry_ids));
      
      // Set project_id from first time entry if not already set
      if (updates.project_id === undefined && timeEntries.length > 0 && timeEntries[0].project_id) {
        setClause.push('project_id = ?');
        params.push(timeEntries[0].project_id);
      }
    }
    
    // Handle line_items and recalculate totals
    if (updates.line_items !== undefined) {
      const line_items = updates.line_items;
      const tax_rate = updates.tax_rate !== undefined ? updates.tax_rate : currentInvoice.tax_rate;
      const discount_amount = updates.discount_amount !== undefined ? updates.discount_amount : currentInvoice.discount_amount;
      
      const subtotal = line_items.reduce((sum, item) => sum + (parseFloat(item.quantity || 1) * parseFloat(item.rate || 0)), 0);
      const tax_amount = subtotal * (parseFloat(tax_rate) / 100);
      const total = subtotal + tax_amount - parseFloat(discount_amount || 0);
      
      setClause.push('line_items = ?');
      params.push(JSON.stringify(line_items));
      setClause.push('subtotal = ?');
      params.push(subtotal);
      setClause.push('tax_amount = ?');
      params.push(tax_amount);
      setClause.push('total = ?');
      params.push(total);
    }
    
    // Handle status transitions
    if (updates.status !== undefined) {
      setClause.push('status = ?');
      params.push(updates.status);
      
      if (updates.status === 'sent' && !currentInvoice.sent_at) {
        setClause.push('sent_at = CURRENT_TIMESTAMP');
      }
      if (updates.status === 'paid' && !currentInvoice.paid_at) {
        setClause.push('paid_at = CURRENT_TIMESTAMP');
      }
    }
    
    // Handle other fields
    const allowedFields = ['client_name', 'client_email', 'client_address', 'issue_date', 'due_date', 'tax_rate', 'discount_amount', 'amount_paid', 'notes', 'payment_terms', 'currency', 'project_id', 'employeeid'];
    
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        setClause.push(`${field} = ?`);
        params.push(updates[field]);
      }
    }
    
    if (setClause.length === 0) {
      return NextResponse.json(
        { error: 'No fields to update' },
        { status: 400 }
      );
    }
    
    setClause.push('updated_at = CURRENT_TIMESTAMP');
    params.push(id, customer_id);
    
    const query = `UPDATE invoices SET ${setClause.join(', ')} WHERE id = ? AND customer_id = ?`;
    await db_query(db, query, params);
    
    return NextResponse.json({ message: 'Invoice updated successfully' });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update invoice', message: error.message },
      { status: 500 }
    );
  }
}


