/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function POST(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const body = await request.json();
    const {
      time_entry_ids,
      client_name,
      client_email,
      due_date,
      tax_rate = 0,
      notes
    } = body;
    
    if (!time_entry_ids || time_entry_ids.length === 0 || !client_name || !due_date) {
      return NextResponse.json(
        { error: 'Time entry IDs, client name, and due date are required' },
        { status: 400 }
      );
    }
    
    // Fetch time entries with employee information
    const placeholders = time_entry_ids.map(() => '?').join(',');
    const entriesQuery = `
      SELECT 
        te.*,
        p.name as project_name,
        e.first_name as employee_first_name,
        e.last_name as employee_last_name,
        e.hourly_rate as employee_hourly_rate
      FROM time_entries te
      LEFT JOIN projects p ON te.project_id = p.id
      LEFT JOIN employees e ON te.employeeid = e.id
      WHERE te.id IN (${placeholders}) AND te.customer_id = ? AND te.is_billable = true
    `;
    
    const entries = await db_query(db, entriesQuery, [...time_entry_ids, customer_id]);
    
    if (entries.length === 0) {
      return NextResponse.json(
        { error: 'No billable time entries found' },
        { status: 400 }
      );
    }
    
    // Group entries by project and employee, then create line items
    const projectGroups = {};
    for (const entry of entries) {
      const projectName = entry.project_name || 'General Work';
      const employeeName = entry.employee_first_name && entry.employee_last_name 
        ? `${entry.employee_first_name} ${entry.employee_last_name}` 
        : null;
      const groupKey = employeeName ? `${projectName} - ${employeeName}` : projectName;
      
      if (!projectGroups[groupKey]) {
        projectGroups[groupKey] = {
          description: groupKey,
          project_name: projectName,
          employee_name: employeeName,
          entries: [],
          totalMinutes: 0,
          totalAmount: 0
        };
      }
      const hours = (entry.duration_minutes || 0) / 60;
      // Use time entry rate, fall back to employee rate, then default
      const rate = parseFloat(entry.hourly_rate) || parseFloat(entry.employee_hourly_rate) || 50;
      const amount = hours * rate;
      
      projectGroups[groupKey].entries.push(entry);
      projectGroups[groupKey].totalMinutes += entry.duration_minutes || 0;
      projectGroups[groupKey].totalAmount += amount;
    }
    
    const line_items = Object.values(projectGroups).map(group => ({
      description: `${group.description} (${(group.totalMinutes / 60).toFixed(2)} hrs)`,
      quantity: 1,
      rate: group.totalAmount,
      amount: group.totalAmount
    }));
    
    // Calculate totals
    const subtotal = line_items.reduce((sum, item) => sum + item.amount, 0);
    const tax_amount = subtotal * (parseFloat(tax_rate) / 100);
    const total = subtotal + tax_amount;
    
    // Generate invoice number
    const year = new Date().getFullYear();
    const countQuery = `SELECT COUNT(*) as count FROM invoices WHERE customer_id = ? AND invoice_number LIKE ?`;
    const countResult = await db_query(db, countQuery, [customer_id, `INV-${year}-%`]);
    const count = parseInt(countResult[0].count) || 0;
    const invoice_number = `INV-${year}-${String(count + 1).padStart(4, '0')}`;
    
    const id = crypto.randomUUID();
    const issue_date = new Date().toISOString().split('T')[0];
    
    const insertQuery = `
      INSERT INTO invoices (
        id, customer_id, invoice_number, status, issue_date, due_date,
        client_name, client_email, line_items, subtotal,
        tax_rate, tax_amount, total, notes, time_entry_ids,
        created_at, updated_at
      ) VALUES (?, ?, ?, 'draft', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `;
    
    await db_query(db, insertQuery, [
      id, customer_id, invoice_number, issue_date, due_date,
      client_name, client_email || null, JSON.stringify(line_items),
      subtotal, tax_rate, tax_amount, total, notes || null,
      JSON.stringify(time_entry_ids)
    ]);
    
    return NextResponse.json({
      id,
      invoice_number,
      total,
      message: 'Invoice created from time entries successfully'
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create invoice from time entries', message: error.message },
      { status: 500 }
    );
  }
}


