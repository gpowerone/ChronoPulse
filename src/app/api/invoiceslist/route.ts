/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function GET(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    // Get customer_id for the authenticated user
    const customerResult = await db_query(db, 'SELECT id FROM customers WHERE userid = ?', [user_id]);
    if (customerResult.length === 0) {
      return NextResponse.json({ error: 'Customer profile not found' }, { status: 404 });
    }
    const customer_id = customerResult[0].id;
    
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');
    const client_name = searchParams.get('client_name');
    const start_date = searchParams.get('start_date');
    const end_date = searchParams.get('end_date');
    const search = searchParams.get('search');
    const page = parseInt(searchParams.get('page')) || 1;
    const limit = parseInt(searchParams.get('limit')) || 20;
    const offset = (page - 1) * limit;
    
    let conditions = ['i.customer_id = ?'];
    let params = [customer_id];
    
    if (status) {
      conditions.push('i.status = ?');
      params.push(status);
    }
    
    if (client_name) {
      conditions.push('i.client_name ILIKE ?');
      params.push(`%${client_name}%`);
    }
    
    if (start_date) {
      conditions.push('i.issue_date >= ?');
      params.push(start_date);
    }
    
    if (end_date) {
      conditions.push('i.issue_date <= ?');
      params.push(end_date);
    }
    
    if (search) {
      conditions.push('(i.invoice_number ILIKE ? OR i.client_name ILIKE ? OR i.notes ILIKE ?)');
      params.push(`%${search}%`, `%${search}%`, `%${search}%`);
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    // Count total
    const countQuery = `SELECT COUNT(*) as total FROM invoices i ${whereClause}`;
    const countResult = await db_query(db, countQuery, params);
    const total = parseInt(countResult[0].total) || 0;
    
    // Fetch invoices with optional customer details
    const query = `
      SELECT 
        i.*,
        c.first_name as customer_first_name,
        c.last_name as customer_last_name,
        c.email as customer_email
      FROM invoices i
      LEFT JOIN customers c ON i.customer_id = c.id
      ${whereClause}
      ORDER BY i.issue_date DESC
      LIMIT ? OFFSET ?
    `;
    
    const result = await db_query(db, query, [...params, limit, offset]);
    
    // Collect all time_entry_ids from invoices for batch fetching
    const allTimeEntryIds = [];
    result.forEach(row => {
      if (row.time_entry_ids && Array.isArray(row.time_entry_ids)) {
        allTimeEntryIds.push(...row.time_entry_ids);
      }
    });
    
    // Fetch time entries if there are any
    let timeEntriesMap = {};
    if (allTimeEntryIds.length > 0) {
      const uniqueIds = [...new Set(allTimeEntryIds)];
      const placeholders = uniqueIds.map(() => '?').join(',');
      const timeEntriesQuery = `
        SELECT 
          te.*,
          p.name as project_name,
          t.title as task_title
        FROM time_entries te
        LEFT JOIN projects p ON te.project_id = p.id
        LEFT JOIN tasks t ON te.task_id = t.id
        WHERE te.id IN (${placeholders})
      `;
      const timeEntriesResult = await db_query(db, timeEntriesQuery, uniqueIds);
      timeEntriesResult.forEach(entry => {
        timeEntriesMap[entry.id] = {
          id: entry.id,
          project_id: entry.project_id,
          project_name: entry.project_name,
          task_id: entry.task_id,
          task_title: entry.task_title,
          description: entry.description,
          start_time: entry.start_time,
          end_time: entry.end_time,
          duration_minutes: entry.duration_minutes,
          is_billable: entry.is_billable,
          hourly_rate: parseFloat(entry.hourly_rate) || 0,
          tags: entry.tags || []
        };
      });
    }
    
    const invoices = result.map(row => ({
      id: row.id,
      customer_id: row.customer_id,
      invoice_number: row.invoice_number,
      status: row.status,
      issue_date: row.issue_date,
      due_date: row.due_date,
      client_name: row.client_name,
      client_email: row.client_email,
      client_address: row.client_address,
      line_items: row.line_items || [],
      subtotal: parseFloat(row.subtotal) || 0,
      tax_rate: parseFloat(row.tax_rate) || 0,
      tax_amount: parseFloat(row.tax_amount) || 0,
      discount_amount: parseFloat(row.discount_amount) || 0,
      total: parseFloat(row.total) || 0,
      amount_paid: parseFloat(row.amount_paid) || 0,
      currency: row.currency,
      notes: row.notes,
      payment_terms: row.payment_terms,
      project_id: row.project_id,
      time_entry_ids: row.time_entry_ids || [],
      time_entries: (row.time_entry_ids || []).map(id => timeEntriesMap[id]).filter(Boolean),
      total_billable_hours: (row.time_entry_ids || []).reduce((sum, id) => {
        const entry = timeEntriesMap[id];
        return sum + (entry && entry.is_billable ? (entry.duration_minutes || 0) / 60 : 0);
      }, 0),
      total_time_cost: (row.time_entry_ids || []).reduce((sum, id) => {
        const entry = timeEntriesMap[id];
        if (entry && entry.is_billable) {
          const hours = (entry.duration_minutes || 0) / 60;
          return sum + (hours * (entry.hourly_rate || 0));
        }
        return sum;
      }, 0),
      paid_at: row.paid_at,
      sent_at: row.sent_at,
      customer: row.customer_id ? { 
        id: row.customer_id, 
        name: `${row.customer_first_name || ''} ${row.customer_last_name || ''}`.trim(),
        email: row.customer_email 
      } : null,
      created_at: row.created_at,
      updated_at: row.updated_at
    }));
    
    return NextResponse.json({
      data: invoices,
      total,
      page,
      limit
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch invoices', message: error.message },
      { status: 500 }
    );
  }
}


