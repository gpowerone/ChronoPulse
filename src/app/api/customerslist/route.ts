/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function GET(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

    if (UserInfo.isadmin !== true) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }

  
  try {
    // Parse query parameters
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status') || '';
    const customer_type = searchParams.get('customer_type') || '';
    const loyalty_tier = searchParams.get('loyalty_tier') || '';
    const newsletter_subscribed = searchParams.get('newsletter_subscribed');
    const sort_by = searchParams.get('sort_by') || 'created_at';
    const sort_order = (searchParams.get('sort_order') || 'DESC').toUpperCase();
    
    // Validate sort_order
    if (sort_order !== 'ASC' && sort_order !== 'DESC') {
      return NextResponse.json(
        { error: 'Invalid sort order. Must be ASC or DESC' },
        { status: 400 }
      );
    }
    
    // Build WHERE clause
    const conditions = [];
    const values = [];
    
    if (search) {
      conditions.push(`(
        LOWER(first_name) LIKE LOWER(?) OR 
        LOWER(last_name) LIKE LOWER(?) OR 
        LOWER(email) LIKE LOWER(?) OR 
        phone LIKE ?
      )`);
      const searchPattern = `%${search}%`;
      values.push(searchPattern, searchPattern, searchPattern, searchPattern);
    }
    
    if (status) {
      conditions.push('status = ?');
      values.push(status);
    }
    
    if (customer_type) {
      conditions.push('customer_type = ?');
      values.push(customer_type);
    }
    
    if (loyalty_tier) {
      conditions.push('loyalty_tier = ?');
      values.push(loyalty_tier);
    }
    
    if (newsletter_subscribed !== null && newsletter_subscribed !== '') {
      conditions.push('newsletter_subscribed = ?');
      values.push(newsletter_subscribed === 'true');
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    // Get total count
    const countQuery = `SELECT COUNT(*) as count FROM customers ${whereClause}`;
    const countResult = await db_query(db, countQuery, values);
    const total = parseInt(countResult[0].count);
    
    // Calculate pagination
    const offset = (page - 1) * limit;
    const pages = Math.ceil(total / limit);
    
    // Validate allowed sort fields
    const allowedSortFields = [
      'created_at', 'updated_at', 'first_name', 'last_name', 'email',
      'total_spent', 'total_orders', 'loyalty_tier', 'status'
    ];
    
    const finalSortBy = allowedSortFields.includes(sort_by) ? sort_by : 'created_at';
    
    // Get customers with pagination
    const dataQuery = `
      SELECT 
        id, userid, first_name, last_name, email, phone,
        date_of_birth, gender, company_name, vat_number,
        customer_type, status, loyalty_points, loyalty_tier,
        total_spent, total_orders, preferred_language,
        preferred_currency, marketing_consent, newsletter_subscribed,
        notes, tags, metadata, created_at, updated_at, last_login_at
      FROM customers 
      ${whereClause}
      ORDER BY ${finalSortBy} ${sort_order}
      LIMIT ? OFFSET ?
    `;
    
    const dataResult = await db_query(db, dataQuery, [...values, limit, offset]);
    
    // Format response
    const customers = dataResult.map(customer => ({
      id: customer.id,
      userid: customer.userid,
      first_name: customer.first_name,
      last_name: customer.last_name,
      email: customer.email,
      phone: customer.phone,
      date_of_birth: customer.date_of_birth,
      gender: customer.gender,
      company_name: customer.company_name,
      vat_number: customer.vat_number,
      customer_type: customer.customer_type,
      status: customer.status,
      loyalty_points: parseInt(customer.loyalty_points),
      loyalty_tier: customer.loyalty_tier,
      total_spent: parseFloat(customer.total_spent),
      total_orders: parseInt(customer.total_orders),
      preferred_language: customer.preferred_language,
      preferred_currency: customer.preferred_currency,
      marketing_consent: customer.marketing_consent,
      newsletter_subscribed: customer.newsletter_subscribed,
      notes: customer.notes,
      tags: customer.tags || [],
      metadata: customer.metadata || {},
      created_at: customer.created_at,
      updated_at: customer.updated_at,
      last_login_at: customer.last_login_at
    }));
    
    return NextResponse.json({
      data: customers,
      pagination: {
        total,
        pages,
        current: page,
        limit
      }
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to list customers', message: error.message },
      { status: 500 }
    );
  }
}


