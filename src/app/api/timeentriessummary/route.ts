/* 
This file is generated by Sitepaige. 
*/
import { NextRequest, NextResponse } from 'next/server';
import { check_auth } from '../Auth/auth';
import { store_file } from '../storage/files';
import { send_email } from '../storage/email';
import { db_init, db_query } from '../db';

export async function GET(request) {
  const db = await db_init();
  let user_id = null;
  let is_admin = false;
  
  
    const UserInfo = await check_auth(db, db_query);
    if (UserInfo.userid.length === 0) { return NextResponse.json({ error: "Forbidden" }, { status: 403 }); }
    user_id = UserInfo.userid;

  
  try {
    const { searchParams } = new URL(request.url);
    const start_date = searchParams.get('start_date');
    const end_date = searchParams.get('end_date');
    const group_by = searchParams.get('group_by') || 'day';
    const project_id = searchParams.get('project_id');
    const is_billable = searchParams.get('is_billable');
    
    if (!start_date || !end_date) {
      return NextResponse.json({ error: 'Start date and end date are required' }, { status: 400 });
    }
    
    let conditions = ['te.userid = ?', 'te.start_time >= ?', 'te.start_time <= ?'];
    let params = [user_id, start_date, end_date + ' 23:59:59'];
    
    if (project_id) {
      conditions.push('te.project_id = ?');
      params.push(project_id);
    }
    
    if (is_billable !== null && is_billable !== undefined && is_billable !== '') {
      conditions.push('te.is_billable = ?');
      params.push(is_billable === 'true');
    }
    
    const whereClause = `WHERE ${conditions.join(' AND ')}`;
    
    // Get totals
    const totalQuery = `
      SELECT 
        COUNT(*) as entries_count,
        COALESCE(SUM(duration_minutes), 0) as total_minutes,
        COALESCE(SUM(CASE WHEN is_billable THEN duration_minutes ELSE 0 END), 0) as billable_minutes,
        COALESCE(SUM(CASE WHEN is_billable AND hourly_rate IS NOT NULL THEN (duration_minutes / 60.0) * hourly_rate ELSE 0 END), 0) as total_earnings
      FROM time_entries te
      ${whereClause}
    `;
    
    const totalResult = await db_query(db, totalQuery, params);
    const totals = totalResult[0];
    
    // Get breakdown based on group_by
    let breakdownQuery;
    let breakdownParams = [...params];
    
    if (group_by === 'project') {
      breakdownQuery = `
        SELECT 
          te.project_id,
          p.name as project_name,
          p.color as project_color,
          COUNT(*) as entries_count,
          COALESCE(SUM(te.duration_minutes), 0) as total_minutes,
          COALESCE(SUM(CASE WHEN te.is_billable THEN te.duration_minutes ELSE 0 END), 0) as billable_minutes
        FROM time_entries te
        LEFT JOIN projects p ON te.project_id = p.id
        ${whereClause}
        GROUP BY te.project_id, p.name, p.color
        ORDER BY total_minutes DESC
      `;
    } else if (group_by === 'task') {
      breakdownQuery = `
        SELECT 
          te.task_id,
          t.title as task_title,
          te.project_id,
          p.name as project_name,
          COUNT(*) as entries_count,
          COALESCE(SUM(te.duration_minutes), 0) as total_minutes,
          COALESCE(SUM(CASE WHEN te.is_billable THEN te.duration_minutes ELSE 0 END), 0) as billable_minutes
        FROM time_entries te
        LEFT JOIN tasks t ON te.task_id = t.id
        LEFT JOIN projects p ON te.project_id = p.id
        ${whereClause}
        GROUP BY te.task_id, t.title, te.project_id, p.name
        ORDER BY total_minutes DESC
      `;
    } else if (group_by === 'week') {
      breakdownQuery = `
        SELECT 
          DATE_TRUNC('week', te.start_time) as week_start,
          COUNT(*) as entries_count,
          COALESCE(SUM(te.duration_minutes), 0) as total_minutes,
          COALESCE(SUM(CASE WHEN te.is_billable THEN te.duration_minutes ELSE 0 END), 0) as billable_minutes
        FROM time_entries te
        ${whereClause}
        GROUP BY DATE_TRUNC('week', te.start_time)
        ORDER BY week_start
      `;
    } else {
      // Default to day
      breakdownQuery = `
        SELECT 
          DATE(te.start_time) as date,
          COUNT(*) as entries_count,
          COALESCE(SUM(te.duration_minutes), 0) as total_minutes,
          COALESCE(SUM(CASE WHEN te.is_billable THEN te.duration_minutes ELSE 0 END), 0) as billable_minutes
        FROM time_entries te
        ${whereClause}
        GROUP BY DATE(te.start_time)
        ORDER BY date
      `;
    }
    
    const breakdownResult = await db_query(db, breakdownQuery, breakdownParams);
    
    const breakdown = breakdownResult.map(row => {
      const base = {
        entries_count: parseInt(row.entries_count) || 0,
        total_minutes: parseInt(row.total_minutes) || 0,
        billable_minutes: parseInt(row.billable_minutes) || 0
      };
      
      if (group_by === 'project') {
        return { ...base, project_id: row.project_id, project_name: row.project_name || 'No Project', project_color: row.project_color };
      } else if (group_by === 'task') {
        return { ...base, task_id: row.task_id, task_title: row.task_title || 'No Task', project_id: row.project_id, project_name: row.project_name };
      } else if (group_by === 'week') {
        return { ...base, week_start: row.week_start };
      } else {
        return { ...base, date: row.date };
      }
    });
    
    return NextResponse.json({
      total_minutes: parseInt(totals.total_minutes) || 0,
      billable_minutes: parseInt(totals.billable_minutes) || 0,
      total_earnings: parseFloat(totals.total_earnings) || 0,
      entries_count: parseInt(totals.entries_count) || 0,
      breakdown
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to generate time summary', message: error.message },
      { status: 500 }
    );
  }
}


